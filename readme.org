#+TITLE: poker-fold
#+PROPERTY: header-args :exports both
#+PROPERTY: header-args :eval no-export

A Haskell poker library exploring:

- speed
- static analysis
- deception

* Development

To create the 7-card lookup table, run

#+begin_src shell
cabal install
poker-fold-writes --hsv7
#+end_src

* Recent Research

Heads-up odds versus any2

[[file:other/odds2.svg]]

Odds versus full table

[[file:other/odds9.svg]]

Tier shifts between heads-up and full table.

[[file:other/compare29.svg]]

top 10% range:

[[file:other/top10.svg]]

* chart references

[[file:other/count.svg]]


[[file:other/fcr.svg]]
[[file:other/freq.svg]]
[[file:other/o2.svg]]
[[file:other/pixelo9.svg]]
[[file:other/rect.svg]]
[[file:other/text.svg]]

* Setup

#+begin_src elisp
(setq haskell-process-args-cabal-repl '("poker-fold:exe:poker-fold-speed"))
#+end_src

#+RESULTS:
| poker-fold:exe:poker-fold-speed |

#+begin_src haskell :results output :exports both
:r
:set prompt " > "
:set -Wno-type-defaults
:set -Wno-name-shadowing
:set -XOverloadedStrings
import Perf
import Chart
import Poker.Charts
import Data.FormatN
import qualified Data.Text as Text
import qualified Data.Map.Strict as Map
import Prettyprinter
putStrLn "ok"
#+end_src

#+RESULTS:
#+begin_example
Loaded GHCi configuration from /Users/tonyday/haskell/poker-fold/.ghci
[1 of 8] Compiling Poker.Card.Storable ( src/Poker/Card/Storable.hs, interpreted )
[2 of 8] Compiling Poker.HandRank.List ( src/Poker/HandRank/List.hs, interpreted )
[3 of 8] Compiling Poker.Lexico     ( src/Poker/Lexico.hs, interpreted )
[4 of 8] Compiling Poker.HandRank.Storable ( src/Poker/HandRank/Storable.hs, interpreted )
[5 of 8] Compiling Poker.Table      ( src/Poker/Table.hs, interpreted )
[6 of 8] Compiling Poker.Random     ( src/Poker/Random.hs, interpreted )
[7 of 8] Compiling Poker.RangedHole ( src/Poker/RangedHole.hs, interpreted )
[8 of 8] Compiling Poker.Charts     ( src/Poker/Charts.hs, interpreted )
Ok, 8 modules loaded.
ghci> Ok, 8 modules loaded.
ok
#+end_example


#+begin_src haskell
writeAllCharts
#+end_src

** ToDo poker-fold chart bugs

- [ ] compare29.svg no data???
- [ ] fcr - bad colours
- [ ] o2 - bad colours, formatting
- [ ] oixelo9 - bad axes label placement, colours
- [ ] rect bad colours



#+RESULTS:

* hand evaluation speed

#+begin_src sh  :results output :exports both
poker-fold-speed
#+end_src

#+RESULTS:
: label1              label2              results
:
: handRank            time                1.44e4
: handRank afap       time                1.33e4
: handRank ffap       time                5.23e6
: handRank f|         time                5.35e6
: handRank |f         time                1.36e4
: handRank |f|        time                6.46e6


* shuffling

#+begin_src sh :results output :exports both
poker-fold-speed --shuffle -n 100000
#+end_src

#+RESULTS:
#+begin_example
label1              label2              results

rvi - list          time                2.40e-1
rvi - list f        time                1.87e2
rvi - single        time                5.43e1
rvi - single f      time                5.53e1
rvil - single       time                2.78e3
rviv - list         time                6.00e-4
rviv - list f       time                1.04e4
rviv - single       time                1.58e3
rviv - single f     time                2.75e3
#+end_example

#+begin_src sh :results output :exports both
poker-fold-speed --shuffle -n 10000
#+end_src

#+RESULTS:
#+begin_example
label1              label2              results

rvi - list          time                2.46e-1
rvi - list f        time                2.01e2
rvi - single        time                5.54e1
rvi - single f      time                5.41e1
rvil - single       time                3.03e3
rviv - list         time                6.00e-4
rviv - list f       time                1.36e4
rviv - single       time                2.95e3
rviv - single f     time                4.10e3
#+end_example


Creating a list of random variates stays lazy as perf is WHNF in the output. Forcing the list fixes this. For a single rvi, the output is computed, and force being added is probably creating an intermediary.

rvil is a list version of rviv.

#+begin_src sh :results output :exports both
poker-fold-speed --shuffle -n 10000 --allocation +RTS -T -RTS
#+end_src

#+RESULTS:
#+begin_example
label1              label2              results

rvi - list          allocation          0
rvi - list f        allocation          5.21e2
rvi - single        allocation          0
rvi - single f      allocation          0
rvil - single       allocation          3.39e3
rviv - list         allocation          0
rviv - list f       allocation          4.13e4
rviv - single       allocation          7.69e3
rviv - single f     allocation          7.68e3
#+end_example

#+begin_src sh :results output :exports both
poker-fold-speed --shuffle -n 100000 --allocation +RTS -T -RTS
#+end_src

#+RESULTS:
#+begin_example
label1              label2              results

rvi - list          allocation          0
rvi - list f        allocation          5.43e2
rvi - single        allocation          0
rvi - single f      allocation          1.88e1
rvil - single       allocation          3.49e3
rviv - list         allocation          0
rviv - list f       allocation          4.13e4
rviv - single       allocation          7.60e3
rviv - single f     allocation          7.60e3
#+end_example

Something allocated to the heap for rvi - single, forced, harming performance.


* handRankS

#+begin_src haskell :results output :exports both
import Data.Bifunctor
:t count
fmap (fmap (bimap getSum ((/10000.0) . fromIntegral))) $ execPerfT ((,) <$> count <*> time) $ handRankS_P 10000
#+end_src

#+RESULTS:
:
: count :: Measure IO (Sum Int)
: fromList [("flushS",(10000,1709.5718)),("kindS",(9239,1160.7222)),("ranksSet",(9703,1324.894)),("straightS",(9703,421.3668))]


handRankS seems bug-free

#+begin_src haskell :results output :exports both
cs = card7sS 100000
:t cs
:t handRankS
V.length $ applyV handRankS cs
#+end_src

#+RESULTS:
:
: cs :: Cards2S
: handRankS :: CardsS -> HandRank
: 100000

#+begin_src haskell :results output :exports both
:t fromIntegral <$> time
:t statify
#+end_src

#+RESULTS:
: fromIntegral <$> time :: Num b => Measure IO b
: statify
:   :: Ord a =>
:      StatDType -> Map.Map a [[Double]] -> Map.Map [a] [Double]
