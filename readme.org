#+TITLE: poker-fold
#+PROPERTY: header-args :exports both
#+PROPERTY: header-args :eval no-export

A Haskell poker library exploring:

- speed
- static analysis
- deception

* Development

To create the 7-card lookup table, run

#+begin_src shell
cabal install
poker-fold-writes --hsv7
#+end_src

* Recent Research

Heads-up odds versus any2

[[file:other/odds2.svg]]

Odds versus full table

[[file:other/odds9.svg]]

Tier shifts between heads-up and full table.

[[file:other/compare29.svg]]

top 10% range:

[[file:other/top10.svg]]

* chart references

[[file:other/count.svg]]


[[file:other/fcr.svg]]
[[file:other/freq.svg]]
[[file:other/o2.svg]]
[[file:other/pixelo9.svg]]
[[file:other/rect.svg]]
[[file:other/text.svg]]

* Setup

#+begin_src elisp
(setq haskell-process-args-cabal-repl '("poker-fold:exe:poker-fold-speed"))
#+end_src

#+RESULTS:
| poker-fold:exe:poker-fold-speed |

#+begin_src haskell :results output :exports both
:r
:set prompt " > "
:set -Wno-type-defaults
:set -Wno-name-shadowing
:set -XOverloadedStrings
import Perf
import Chart
import Data.FormatN
import qualified Data.Text as Text
import qualified Data.Map.Strict as Map
import Prettyprinter
(Just m) <- readSomeRanges
s = m Map.! "o2"
putStrLn "ok"
#+end_src

#+RESULTS:
: [7 of 8] Compiling Poker.RangedHole ( src/Poker/RangedHole.hs, interpreted )
: [8 of 8] Compiling Poker.Charts     ( src/Poker/Charts.hs, interpreted ) [Poker.RangedHole changed]
: Ok, 8 modules loaded.
: >  >  >  >  >  >  >  >  >  >  >  > ok

* hand evaluation speed

#+begin_src sh  :results output :exports both
poker-fold-speed
#+end_src

#+RESULTS:
: label1              label2              results
:
: handRank            time                1.44e4
: handRank afap       time                1.33e4
: handRank ffap       time                5.23e6
: handRank f|         time                5.35e6
: handRank |f         time                1.36e4
: handRank |f|        time                6.46e6


* shuffling

#+begin_src sh :results output :exports both
poker-fold-speed --shuffle -n 100000
#+end_src

#+RESULTS:
#+begin_example
label1              label2              results

rvi - list          time                2.40e-1
rvi - list f        time                1.87e2
rvi - single        time                5.43e1
rvi - single f      time                5.53e1
rvil - single       time                2.78e3
rviv - list         time                6.00e-4
rviv - list f       time                1.04e4
rviv - single       time                1.58e3
rviv - single f     time                2.75e3
#+end_example

#+begin_src sh :results output :exports both
poker-fold-speed --shuffle -n 10000
#+end_src

#+RESULTS:
#+begin_example
label1              label2              results

rvi - list          time                2.46e-1
rvi - list f        time                2.01e2
rvi - single        time                5.54e1
rvi - single f      time                5.41e1
rvil - single       time                3.03e3
rviv - list         time                6.00e-4
rviv - list f       time                1.36e4
rviv - single       time                2.95e3
rviv - single f     time                4.10e3
#+end_example


Creating a list of random variates stays lazy as perf is WHNF in the output. Forcing the list fixes this. For a single rvi, the output is computed, and force being added is probably creating an intermediary.

rvil is a list version of rviv.

#+begin_src sh :results output :exports both
poker-fold-speed --shuffle -n 10000 --allocation +RTS -T -RTS
#+end_src

#+RESULTS:
#+begin_example
label1              label2              results

rvi - list          allocation          0
rvi - list f        allocation          5.21e2
rvi - single        allocation          0
rvi - single f      allocation          0
rvil - single       allocation          3.39e3
rviv - list         allocation          0
rviv - list f       allocation          4.13e4
rviv - single       allocation          7.69e3
rviv - single f     allocation          7.68e3
#+end_example

#+begin_src sh :results output :exports both
poker-fold-speed --shuffle -n 100000 --allocation +RTS -T -RTS
#+end_src

#+RESULTS:
#+begin_example
label1              label2              results

rvi - list          allocation          0
rvi - list f        allocation          5.43e2
rvi - single        allocation          0
rvi - single f      allocation          1.88e1
rvil - single       allocation          3.49e3
rviv - list         allocation          0
rviv - list f       allocation          4.13e4
rviv - single       allocation          7.60e3
rviv - single f     allocation          7.60e3
#+end_example

Something allocated to the heap for rvi - single, forced, harming performance.


* handRankS

#+begin_src haskell :results output :exports both
import Data.Bifunctor
:t count
fmap (fmap (bimap getSum ((/10000.0) . fromIntegral))) $ execPerfT ((,) <$> count <*> time) $ handRankS_P 10000
#+end_src

#+RESULTS:
:
: count :: Measure IO (Sum Int)
: fromList [("flushS",(10000,1709.5718)),("kindS",(9239,1160.7222)),("ranksSet",(9703,1324.894)),("straightS",(9703,421.3668))]


handRankS seems bug-free

#+begin_src haskell :results output :exports both
cs = card7sS 100000
:t cs
:t handRankS
V.length $ applyV handRankS cs
#+end_src

#+RESULTS:
:
: cs :: Cards2S
: handRankS :: CardsS -> HandRank
: 100000

#+begin_src haskell :results output :exports both
:t fromIntegral <$> time
:t statify
#+end_src

#+RESULTS:
: fromIntegral <$> time :: Num b => Measure IO b
: statify
:   :: Ord a =>
:      StatDType -> Map.Map a [[Double]] -> Map.Map [a] [Double]


* evTables


#+begin_src haskell :results output
ev 2 100 [rcf s 10 0.2 0.9, rcf s 10 0.3 0.9, rcf s 10 0.1 0.5, rcf s 10 0.6 0.8]
#+end_src

#+RESULTS:
: <interactive>:56:7: warning: [-Wname-shadowing]
:     This binding for ‘m’ shadows the existing binding
:       defined at <interactive>:52:7
: <interactive>:57:1: warning: [-Wname-shadowing]
:     This binding for ‘s’ shadows the existing binding
:       defined at <interactive>:53:1
: Just (-0.14000000000000057)

#+begin_src haskell :results output
ev 2 100 [rcf s 10 0.2 0.9, rcf s 10 0.3 0.9, rcf s 10 0.1 0.5, rcf s 10 0.6 0.8]
#+end_src

#+RESULTS:
: [-0.14000000000000057,0.14000000000000057]

#+begin_src haskell :results output
:set -XOverloadedLists
result2 s 100 [0.2, 0.8, 0.3, 0.5, 0.8]
#+end_src

#+RESULTS:
:
: [-0.46000000000000085, 0.46000000000000085]
