#+TITLE: poker-fold
#+PROPERTY: header-args :exports both
#+PROPERTY: header-args :eval no-export

A Haskell poker library exploring:

- speed
- static analysis
- deception

* Recent Research

Heads-up odds versus any2

[[file:other/odds2.svg]]

Odds versus full table

[[file:other/odds9.svg]]

Tier shifts between heads-up and full table.

[[file:other/compare29.svg]]

top 10% range:

[[file:other/top10.svg]]


* chart references

[[file:other/count.svg]]


[[file:other/fcr.svg]]
[[file:other/freq.svg]]
[[file:other/o2.svg]]
[[file:other/pixelo9.svg]]
[[file:other/rect.svg]]
[[file:other/text.svg]]

* Setup

#+begin_src elisp
(setq haskell-process-args-cabal-repl '("poker-fold:exe:poker-fold-speed"))
#+end_src

#+RESULTS:
| poker-fold:exe:poker-fold-speed |

#+begin_src haskell :results output :exports both
:r
:set prompt " > "
:set -Wno-type-defaults
:set -Wno-name-shadowing
:set -XOverloadedStrings
import Perf
import Chart
import Data.FormatN
import qualified Data.Text as Text
import qualified Data.Map.Strict as Map
import Prettyprinter
putStrLn "ok"
#+end_src

#+RESULTS:
: Loaded GHCi configuration from /Users/tonyday/haskell/poker-fold/.ghci
: [1 of 1] Compiling Main             ( app/speed.hs, interpreted )
: Ok, one module loaded.
: *Main> Ok, one module loaded.
: >  >  >  >  >  >  >  >  >  > ok

* shuffling

#+begin_src sh :results output
poker-fold-speed --shuffle -n 100000
#+end_src

#+RESULTS:
#+begin_example
label1              label2              results

rvi - list          time                2.40e-1
rvi - list f        time                1.87e2
rvi - single        time                5.43e1
rvi - single f      time                5.53e1
rvil - single       time                2.78e3
rviv - list         time                6.00e-4
rviv - list f       time                1.04e4
rviv - single       time                1.58e3
rviv - single f     time                2.75e3
#+end_example

#+begin_src sh :results output
poker-fold-speed --shuffle -n 10000
#+end_src

#+RESULTS:
#+begin_example
label1              label2              results

rvi - list          time                2.46e-1
rvi - list f        time                2.01e2
rvi - single        time                5.54e1
rvi - single f      time                5.41e1
rvil - single       time                3.03e3
rviv - list         time                6.00e-4
rviv - list f       time                1.36e4
rviv - single       time                2.95e3
rviv - single f     time                4.10e3
#+end_example


Creating a list of random variates stays lazy as perf is WHNF in the output. Forcing the list fixes this. For a single rvi, the output is computed, and force being added is probably creating an intermediary.

rvil is a list version of rviv.

#+begin_src sh :results output
poker-fold-speed --shuffle -n 10000 --allocation +RTS -T -RTS
#+end_src

#+RESULTS:
#+begin_example
label1              label2              results

rvi - list          allocation          0
rvi - list f        allocation          5.21e2
rvi - single        allocation          0
rvi - single f      allocation          0
rvil - single       allocation          3.39e3
rviv - list         allocation          0
rviv - list f       allocation          4.13e4
rviv - single       allocation          7.69e3
rviv - single f     allocation          7.68e3
#+end_example

#+begin_src sh :results output
poker-fold-speed --shuffle -n 100000 --allocation +RTS -T -RTS
#+end_src

#+RESULTS:
#+begin_example
label1              label2              results

rvi - list          allocation          0
rvi - list f        allocation          5.43e2
rvi - single        allocation          0
rvi - single f      allocation          1.88e1
rvil - single       allocation          3.49e3
rviv - list         allocation          0
rviv - list f       allocation          4.13e4
rviv - single       allocation          7.60e3
rviv - single f     allocation          7.60e3
#+end_example

Something allocated to the heap for rvi - single, forced, harming performance.


* handRankS

#+begin_src haskell :results output
import Data.Bifunctor
:t count
fmap (fmap (bimap getSum ((/10000.0) . fromIntegral))) $ execPerfT ((,) <$> count <*> time) $ handRankS_P 10000
#+end_src

#+RESULTS:
:
: count :: Measure IO (Sum Int)
: fromList [("flushS",(10000,1709.5718)),("kindS",(9239,1160.7222)),("ranksSet",(9703,1324.894)),("straightS",(9703,421.3668))]


handRankS seems bug-free

#+begin_src haskell :results output
cs = card7sS 100000
:t cs
:t handRankS
V.length $ applyV handRankS cs
#+end_src

#+RESULTS:
:
: cs :: Cards2S
: handRankS :: CardsS -> HandRank
: 100000

#+begin_src haskell :results output
:t fromIntegral <$> time
:t statify
#+end_src

#+RESULTS:
: fromIntegral <$> time :: Num b => Measure IO b
: statify
:   :: Ord a =>
:      StatDType -> Map.Map a [[Double]] -> Map.Map [a] [Double]
