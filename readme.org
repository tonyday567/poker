#+TITLE: poker-fold
#+PROPERTY: header-args :exports both
#+PROPERTY: header-args :eval no-export

A Haskell poker library exploring:

- speed
- static analysis
- deception

* imports

#+begin_src haskell :results output :exports both
:r
:set prompt " > "
:set -Wno-type-defaults
:set -Wno-name-shadowing
:set -XOverloadedStrings
import Perf
import Chart
import Data.FormatN
import Optics.Core
import qualified Data.Text as Text
import qualified Data.Map.Strict as Map
import Prettyprinter
putStrLn "ok"
#+end_src

#+RESULTS:
: Ok, 8 modules loaded.
: >
: ok

#+begin_src haskell
:t iso
#+end_src

#+RESULTS:
: iso :: (s -> a) -> (b -> t) -> Iso s t a b



* Instaling the lookup table

To create the 7-card lookup table, run

#+begin_src sh
cabal install
poker-fold-writes --hvs7
#+end_src

Canned results for:

o2 - Different from any2?
o9 - Odds versus a full table of any2
count - combinatorial count for each shapedHole (/ 51*52 for frequency)
any2 - headsup odds versus any2

#+begin_src sh
poker-fold-writes --sims 100000
#+end_src

* ToDo Redoing the poker charts

- [X] install the lookup table
- [ ] check some.str

#+begin_src haskell :results output
import Data.Functor.Rep
import qualified Data.Map.Strict as Map
import Optics.Core
(Just m) <- readSomeRanges
index (m Map.! "o2") (view shapedHoleS $ MkPair Ace)
#+end_src

#+RESULTS:
: 0.500045


* Next fix o2

any2 is frequency

#+begin_src haskell :results output
index (m Map.! "count") (view shapedHoleS $ MkSuited Ace Two)
(52 * 51) * index (m Map.! "any2") (view shapedHoleS $ MkSuited Ace Two)
#+end_src

#+RESULTS:
: 8.0
: 8.0

#+begin_src haskell
m Map.! "o2"
#+end_src

#+RESULTS:
| 0.499935 | 0.499875 | 0.5002 | 0.50007 | 0.499795 | 0.499965 | 0.500085 | 0.50018 | 0.50002 | 0.50007 | 0.500015 | 0.499605 | 0.499995 | 0.500115 | 0.50018 | 0.4997 | 0.500005 | 0.499645 | 0.50003 | 0.500085 | 0.498905 | 0.499895 | 0.49975 | 0.499955 | 0.499595 | 0.500605 | 0.50008 | 0.499435 | 0.49992 | 0.499265 | 0.499755 | 0.499715 | 0.499675 | 0.50005 | 0.49974 | 0.500425 | 0.5 | 0.499815 | 0.49988 | 0.49961 | 0.5003 | 0.499895 | 0.500285 | 0.500065 | 0.500375 | 0.500235 | 0.500175 | 0.499775 | 0.499715 | 0.499905 | 0.499485 | 0.499535 | 0.500015 | 0.49969 | 0.499705 | 0.500245 | 0.500355 | 0.49968 | 0.500195 | 0.50006 | 0.49982 | 0.5002 | 0.4996 | 0.499885 | 0.499975 | 0.499715 | 0.5001 | 0.49999 | 0.500285 | 0.50027 | 0.499805 | 0.499625 | 0.500175 | 0.500345 | 0.50022 | 0.49986 | 0.500295 | 0.49974 | 0.499955 | 0.500315 | 0.49966 | 0.5001 | 0.5002 | 0.499415 | 0.499955 | 0.49986 | 0.49999 | 0.499935 | 0.49962 | 0.50012 | 0.5003 | 0.500115 | 0.499105 | 0.49994 | 0.50007 | 0.500185 | 0.49984 | 0.50051 | 0.499495 | 0.500035 | 0.50044 | 0.49977 | 0.50029 | 0.500855 | 0.50033 | 0.50004 | 0.499815 | 0.499845 | 0.499945 | 0.499875 | 0.499735 | 0.49976 | 0.499655 | 0.499335 | 0.500265 | 0.50044 | 0.500135 | 0.499635 | 0.499705 | 0.50031 | 0.49945 | 0.500345 | 0.4998 | 0.50023 | 0.49994 | 0.499465 | 0.49982 | 0.499815 | 0.49996 | 0.500575 | 0.499295 | 0.49999 | 0.499855 | 0.499175 | 0.50023 | 0.499885 | 0.500365 | 0.499875 | 0.500075 | 0.499735 | 0.50057 | 0.49994 | 0.49976 | 0.499425 | 0.49946 | 0.499475 | 0.49933 | 0.49955 | 0.499655 | 0.49998 | 0.499575 | 0.50033 | 0.500335 | 0.49991 | 0.499435 | 0.499595 | 0.49989 | 0.50034 | 0.4999 | 0.4997 | 0.4999 | 0.499655 | 0.500715 | 0.500015 | 0.50029 | 0.50025 | 0.49958 | 0.4994 | 0.500045 |

*** ToDo winHole bugged

#+begin_src haskell
winHole (MkPair Ace) 2 1000
#+end_src

#+RESULTS:
: 0.495

#+begin_src haskell
(\x -> bool (0 :: Double) (1 / fromIntegral (length x)) (0 `elem` x)) . bestLiveHole <$> tablesB 2 (MkPair Ace) 0 100
#+end_src

#+RESULTS:
| 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 1.0 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 1.0 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 | 0.5 |


Checking lookupHRUnsafe

 #+begin_src haskell
import Poker.HandRank.Storable
:t lookupHRUnsafe
 #+end_src

#+RESULTS:
: lookupHRUnsafe :: Cards -> Word16


#+begin_src haskell :results output
cs = [Card Ace Heart,Card Seven Spade,Card Ten Heart,Card Five Spade,Card Six Club, Card Seven Heart,Card Six Spade]
cs' = [Card Ten Club, Card Five Spade,Card Ten Heart,Card Five Spade,Card Six Club, Card Seven Heart,Card Six Spade]
css = [cs, cs']
#+end_src

#+RESULTS:
#+begin_example
<interactive>:117:7: error:
    Ambiguous occurrence ‘Card’
    It could refer to
       either ‘Poker.Card’,
              imported from ‘Poker’ at src/Poker/RangedHole.hs:116:1-40
              (and originally defined in ‘Poker.Cards’)
           or ‘Poker.Card.Storable.Card’,
              imported from ‘Poker.Card.Storable’ at src/Poker/RangedHole.hs:117:1-41
              (and originally defined at src/Poker/Card/Storable.hs:147:16-41)

<interactive>:117:22: error:
    Ambiguous occurrence ‘Card’
    It could refer to
       either ‘Poker.Card’,
              imported from ‘Poker’ at src/Poker/RangedHole.hs:116:1-40
              (and originally defined in ‘Poker.Cards’)
           or ‘Poker.Card.Storable.Card’,
              imported from ‘Poker.Card.Storable’ at src/Poker/RangedHole.hs:117:1-41
              (and originally defined at src/Poker/Card/Storable.hs:147:16-41)

<interactive>:117:39: error:
    Ambiguous occurrence ‘Card’
    It could refer to
       either ‘Poker.Card’,
              imported from ‘Poker’ at src/Poker/RangedHole.hs:116:1-40
              (and originally defined in ‘Poker.Cards’)
           or ‘Poker.Card.Storable.Card’,
              imported from ‘Poker.Card.Storable’ at src/Poker/RangedHole.hs:117:1-41
              (and originally defined at src/Poker/Card/Storable.hs:147:16-41)

<interactive>:117:54: error:
    Ambiguous occurrence ‘Card’
    It could refer to
       either ‘Poker.Card’,
              imported from ‘Poker’ at src/Poker/RangedHole.hs:116:1-40
              (and originally defined in ‘Poker.Cards’)
           or ‘Poker.Card.Storable.Card’,
              imported from ‘Poker.Card.Storable’ at src/Poker/RangedHole.hs:117:1-41
              (and originally defined at src/Poker/Card/Storable.hs:147:16-41)

<interactive>:117:70: error:
    Ambiguous occurrence ‘Card’
    It could refer to
       either ‘Poker.Card’,
              imported from ‘Poker’ at src/Poker/RangedHole.hs:116:1-40
              (and originally defined in ‘Poker.Cards’)
           or ‘Poker.Card.Storable.Card’,
              imported from ‘Poker.Card.Storable’ at src/Poker/RangedHole.hs:117:1-41
              (and originally defined at src/Poker/Card/Storable.hs:147:16-41)

<interactive>:117:85: error:
    Ambiguous occurrence ‘Card’
    It could refer to
       either ‘Poker.Card’,
              imported from ‘Poker’ at src/Poker/RangedHole.hs:116:1-40
              (and originally defined in ‘Poker.Cards’)
           or ‘Poker.Card.Storable.Card’,
              imported from ‘Poker.Card.Storable’ at src/Poker/RangedHole.hs:117:1-41
              (and originally defined at src/Poker/Card/Storable.hs:147:16-41)

<interactive>:117:102: error:
    Ambiguous occurrence ‘Card’
    It could refer to
       either ‘Poker.Card’,
              imported from ‘Poker’ at src/Poker/RangedHole.hs:116:1-40
              (and originally defined in ‘Poker.Cards’)
           or ‘Poker.Card.Storable.Card’,
              imported from ‘Poker.Card.Storable’ at src/Poker/RangedHole.hs:117:1-41
              (and originally defined at src/Poker/Card/Storable.hs:147:16-41)
<interactive>:118:8: error:
    Ambiguous occurrence ‘Card’
    It could refer to
       either ‘Poker.Card’,
              imported from ‘Poker’ at src/Poker/RangedHole.hs:116:1-40
              (and originally defined in ‘Poker.Cards’)
           or ‘Poker.Card.Storable.Card’,
              imported from ‘Poker.Card.Storable’ at src/Poker/RangedHole.hs:117:1-41
              (and originally defined at src/Poker/Card/Storable.hs:147:16-41)

<interactive>:118:23: error:
    Ambiguous occurrence ‘Card’
    It could refer to
       either ‘Poker.Card’,
              imported from ‘Poker’ at src/Poker/RangedHole.hs:116:1-40
              (and originally defined in ‘Poker.Cards’)
           or ‘Poker.Card.Storable.Card’,
              imported from ‘Poker.Card.Storable’ at src/Poker/RangedHole.hs:117:1-41
              (and originally defined at src/Poker/Card/Storable.hs:147:16-41)

<interactive>:118:39: error:
    Ambiguous occurrence ‘Card’
    It could refer to
       either ‘Poker.Card’,
              imported from ‘Poker’ at src/Poker/RangedHole.hs:116:1-40
              (and originally defined in ‘Poker.Cards’)
           or ‘Poker.Card.Storable.Card’,
              imported from ‘Poker.Card.Storable’ at src/Poker/RangedHole.hs:117:1-41
              (and originally defined at src/Poker/Card/Storable.hs:147:16-41)

<interactive>:118:54: error:
    Ambiguous occurrence ‘Card’
    It could refer to
       either ‘Poker.Card’,
              imported from ‘Poker’ at src/Poker/RangedHole.hs:116:1-40
              (and originally defined in ‘Poker.Cards’)
           or ‘Poker.Card.Storable.Card’,
              imported from ‘Poker.Card.Storable’ at src/Poker/RangedHole.hs:117:1-41
              (and originally defined at src/Poker/Card/Storable.hs:147:16-41)

<interactive>:118:70: error:
    Ambiguous occurrence ‘Card’
    It could refer to
       either ‘Poker.Card’,
              imported from ‘Poker’ at src/Poker/RangedHole.hs:116:1-40
              (and originally defined in ‘Poker.Cards’)
           or ‘Poker.Card.Storable.Card’,
              imported from ‘Poker.Card.Storable’ at src/Poker/RangedHole.hs:117:1-41
              (and originally defined at src/Poker/Card/Storable.hs:147:16-41)

<interactive>:118:85: error:
    Ambiguous occurrence ‘Card’
    It could refer to
       either ‘Poker.Card’,
              imported from ‘Poker’ at src/Poker/RangedHole.hs:116:1-40
              (and originally defined in ‘Poker.Cards’)
           or ‘Poker.Card.Storable.Card’,
              imported from ‘Poker.Card.Storable’ at src/Poker/RangedHole.hs:117:1-41
              (and originally defined at src/Poker/Card/Storable.hs:147:16-41)

<interactive>:118:102: error:
    Ambiguous occurrence ‘Card’
    It could refer to
       either ‘Poker.Card’,
              imported from ‘Poker’ at src/Poker/RangedHole.hs:116:1-40
              (and originally defined in ‘Poker.Cards’)
           or ‘Poker.Card.Storable.Card’,
              imported from ‘Poker.Card.Storable’ at src/Poker/RangedHole.hs:117:1-41
              (and originally defined at src/Poker/Card/Storable.hs:147:16-41)
<interactive>:119:8: error:
    Variable not in scope: cs
    Suggested fix: Perhaps use ‘cos’ (imported from Prelude)

<interactive>:119:12: error: Variable not in scope: cs'
#+end_example



#+begin_src haskell
:t (view (re shapedHoleS) (MkPair Ace))
#+end_src
#+RESULTS:
: <interactive>:1:25: error:
:     • Couldn't match expected type ‘ShapedHoleS’
:                   with actual type ‘ShapedHole’
:     • In the second argument of ‘view’, namely ‘(MkPair Ace)’
:       In the expression: view (re shapedHoleS) (MkPair Ace)

#+begin_src haskell
:t view shapedHoleS $ MkSuited Jack Ten
#+end_src

#+RESULTS:
: view shapedHoleS $ MkSuited Jack Ten :: ShapedHoleS


- [ ] locate old chart production:

  -rw-r--r--  1 tonyday staff  11K Mar 26 21:24 compare29.svg
  -rw-r--r--  1 tonyday staff  87K Mar 11 07:24 count.svg
  -rw-r--r--  1 tonyday staff  59K Mar 26 21:24 fcr.svg
  -rw-r--r--  1 tonyday staff  87K Mar 11 07:24 freq.svg
  -rw-r--r--  1 tonyday staff  59K Mar 26 21:24 o2.svg
  -rw-r--r--  1 tonyday staff  87K Mar 11 07:24 odds2.svg
  -rw-r--r--  1 tonyday staff  87K Mar 11 07:24 odds9.svg
  -rw-r--r--  1 tonyday staff  50K Mar 26 21:24 pixelo9.svg
  -rw-r--r--  1 tonyday staff  60K Mar 26 21:24 rect.svg
  -rw-r--r--  1 tonyday staff 9.5K Mar 11 07:24 some.str
  -rw-r--r--  1 tonyday staff  65K Mar 11 07:24 text.svg
  -rw-r--r--  1 tonyday staff  88K Mar 11 07:24 top10.svg

** writeAllCharts

- [ ] rect
- [ ] o2
- [ ] fcr
- [ ] pixelo9
- [ ] compare29

** other
- [ ] count
- [ ] freq
- [ ] odds2 odds9
  winodds 2 1000
  same as 02
- [ ] top10
- [ ] text

* Recent Research

Heads-up odds versus any2

[[file:other/odds2.svg]]

Odds versus full table

[[file:other/odds9.svg]]

Tier shifts between heads-up and full table.

[[file:other/compare29.svg]]

top 10% range:

[[file:other/top10.svg]]

* chart references

[[file:other/count.svg]]


[[file:other/fcr.svg]]
[[file:other/freq.svg]]
[[file:other/o2.svg]]
[[file:other/pixelo9.svg]]
[[file:other/rect.svg]]
[[file:other/text.svg]]

* Speed testing & development

#+begin_src elisp
(setq haskell-process-args-cabal-repl '("poker-fold:exe:poker-fold-speed"))
#+end_src

#+begin_src haskell :results output :exports both
:r
:set prompt " > "
:set -Wno-type-defaults
:set -Wno-name-shadowing
:set -XOverloadedStrings
import Perf
import Chart
import Poker.Charts
import Data.FormatN
import qualified Data.Text as Text
import qualified Data.Map.Strict as Map
import Prettyprinter
putStrLn "ok"
#+end_src

#+RESULTS:
#+begin_example
Loaded GHCi configuration from /Users/tonyday/haskell/poker-fold/.ghci
[1 of 8] Compiling Poker.Card.Storable ( src/Poker/Card/Storable.hs, interpreted )
[2 of 8] Compiling Poker.HandRank.List ( src/Poker/HandRank/List.hs, interpreted )
[3 of 8] Compiling Poker.Lexico     ( src/Poker/Lexico.hs, interpreted )
[4 of 8] Compiling Poker.HandRank.Storable ( src/Poker/HandRank/Storable.hs, interpreted )
[5 of 8] Compiling Poker.Table      ( src/Poker/Table.hs, interpreted )
[6 of 8] Compiling Poker.Random     ( src/Poker/Random.hs, interpreted )
[7 of 8] Compiling Poker.RangedHole ( src/Poker/RangedHole.hs, interpreted )
[8 of 8] Compiling Poker.Charts     ( src/Poker/Charts.hs, interpreted )
Ok, 8 modules loaded.
ghci> Ok, 8 modules loaded.
>
ok
#+end_example


#+begin_src haskell
writeAllCharts
#+end_src

** ToDo poker-fold chart bugs

- [ ] compare29.svg no data???
- [ ] fcr - bad colours
- [ ] o2 - bad colours, formatting
- [ ] oixelo9 - bad axes label placement, colours
- [ ] rect bad colours



#+RESULTS:

** hand evaluation speed

#+begin_src sh  :results output :exports both
poker-fold-speed
#+end_src

#+RESULTS:
: label1              label2              results
:
: handRank            time                1.44e4
: handRank afap       time                1.33e4
: handRank ffap       time                5.23e6
: handRank f|         time                5.35e6
: handRank |f         time                1.36e4
: handRank |f|        time                6.46e6

** shuffling

#+begin_src sh :results output :exports both
poker-fold-speed --shuffle -n 100000
#+end_src

#+RESULTS:
#+begin_example
label1              label2              results

rvi - list          time                2.40e-1
rvi - list f        time                1.87e2
rvi - single        time                5.43e1
rvi - single f      time                5.53e1
rvil - single       time                2.78e3
rviv - list         time                6.00e-4
rviv - list f       time                1.04e4
rviv - single       time                1.58e3
rviv - single f     time                2.75e3
#+end_example

#+begin_src sh :results output :exports both
poker-fold-speed --shuffle -n 10000
#+end_src

#+RESULTS:
#+begin_example
label1              label2              results

rvi - list          time                2.46e-1
rvi - list f        time                2.01e2
rvi - single        time                5.54e1
rvi - single f      time                5.41e1
rvil - single       time                3.03e3
rviv - list         time                6.00e-4
rviv - list f       time                1.36e4
rviv - single       time                2.95e3
rviv - single f     time                4.10e3
#+end_example


Creating a list of random variates stays lazy as perf is WHNF in the output. Forcing the list fixes this. For a single rvi, the output is computed, and force being added is probably creating an intermediary.

rvil is a list version of rviv.

#+begin_src sh :results output :exports both
poker-fold-speed --shuffle -n 10000 --allocation +RTS -T -RTS
#+end_src

#+RESULTS:
#+begin_example
label1              label2              results

rvi - list          allocation          0
rvi - list f        allocation          5.21e2
rvi - single        allocation          0
rvi - single f      allocation          0
rvil - single       allocation          3.39e3
rviv - list         allocation          0
rviv - list f       allocation          4.13e4
rviv - single       allocation          7.69e3
rviv - single f     allocation          7.68e3
#+end_example

#+begin_src sh :results output :exports both
poker-fold-speed --shuffle -n 100000 --allocation +RTS -T -RTS
#+end_src

#+RESULTS:
#+begin_example
label1              label2              results

rvi - list          allocation          0
rvi - list f        allocation          5.43e2
rvi - single        allocation          0
rvi - single f      allocation          1.88e1
rvil - single       allocation          3.49e3
rviv - list         allocation          0
rviv - list f       allocation          4.13e4
rviv - single       allocation          7.60e3
rviv - single f     allocation          7.60e3
#+end_example

Something allocated to the heap for rvi - single, forced, harming performance.

** handRankS

#+begin_src haskell :results output :exports both
import Data.Bifunctor
:t count
fmap (fmap (bimap getSum ((/10000.0) . fromIntegral))) $ execPerfT ((,) <$> count <*> time) $ handRankS_P 10000
#+end_src

#+RESULTS:
:
: count :: Measure IO (Sum Int)
: fromList [("flushS",(10000,1709.5718)),("kindS",(9239,1160.7222)),("ranksSet",(9703,1324.894)),("straightS",(9703,421.3668))]


handRankS seems bug-free

#+begin_src haskell :results output :exports both
cs = card7sS 100000
:t cs
:t handRankS
V.length $ applyV handRankS cs
#+end_src

#+RESULTS:
:
: cs :: Cards2S
: handRankS :: CardsS -> HandRank
: 100000

#+begin_src haskell :results output :exports both
:t fromIntegral <$> time
:t statify
#+end_src

#+RESULTS:
: fromIntegral <$> time :: Num b => Measure IO b
: statify
:   :: Ord a =>
:      StatDType -> Map.Map a [[Double]] -> Map.Map [a] [Double]
