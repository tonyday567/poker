#+TITLE: poker-fold
#+PROPERTY: header-args :exports both
#+PROPERTY: header-args :eval no-export

A Haskell poker library exploring:

- speed
- static analysis
- deception

* imports

#+begin_src haskell :results output :exports both
:r
:set prompt " > "
:set -Wno-type-defaults
:set -Wno-name-shadowing
:set -XOverloadedStrings
import Poker.Card
import Poker.Card.Storable
import Poker.HandRank
import Poker.Range
import Poker.Random
import Poker.Lexico
import Poker.Charts
import Chart
import Data.FormatN
import Optics.Core
import Prettyprinter
import qualified Data.Text as Text
import qualified Data.Map.Strict as Map
import qualified Data.Vector.Storable as S
import Data.Functor.Rep
import Perf
putStrLn "ok"
#+end_src

#+RESULTS:
: [8 of 8] Compiling Poker.Charts     ( src/Poker/Charts.hs, interpreted )
: Ok, 8 modules loaded.
: >
: ok

** hvs7

hvs7 is a vector of hand rankings for 7 card vectors in reverse lexicographic order.

#+begin_src haskell :results output
s <- hvs7
l = S.length s
l
#+end_src

#+RESULTS:
: 133784560

The first element of the vector corresponds to:

#+begin_src haskell :results output
hand0 = fromLexiPosR 52 7 0 & fmap fromIntegral & S.fromList & CardsS
"hand:" <> pretty hand0
"hand rank index:" <> pretty (s S.! 0)
"hand rank:" <> pretty (lexiToHR $ s S.! 0)
#+end_src

#+RESULTS:
: hand:KdKhKsAcAdAhAs
: hand rank index:7451
: hand rank:FourOfAKind Ace King

And the last element corresponds to:

#+begin_src haskell :results output
hand1 = fromLexiPosR 52 7 (l-1) & fmap fromIntegral & S.fromList & CardsS
"hand:" <> pretty hand1
"hand rank index:" <> pretty (s S.! (l-1))
"hand rank:" <> pretty (lexiToHR $ s S.! (l-1))
#+end_src

#+RESULTS:
: hand:2c2d2h2s3c3d3h
: hand rank index:7296
: hand rank:FourOfAKind Two Three

And the one hundred millionth

#+begin_src haskell :results output
handb = fromLexiPosR 52 7 (100000000-1) & fmap fromIntegral & S.fromList & CardsS
"hand:" <> pretty handb
"hand rank index:" <> pretty (s S.! (100000000-1))
"hand rank:" <> pretty (lexiToHR $ s S.! (100000000-1))
#+end_src

#+RESULTS:
: hand:5s6s7d8dTcThQs
: hand rank index:3141
: hand rank:OnePair Ten Queen Eight Seven

#+begin_src haskell
pretty $ lexiToHR 3141
#+end_src

#+RESULTS:
: OnePair Ten Queen Eight Seven

* Installing the lookup table

To create the 7-card lookup table, run

#+begin_src sh
cabal install
poker-fold-writes --hvs7
#+end_src

Canned results for:

o2 - Different from any2?
o9 - Odds versus a full table of any2
count - combinatorial count for each startingHand (/ 51*52 for frequency)
any2 - headsup odds versus any2

#+begin_src sh
poker-fold-writes --sims 100000
#+end_src

* ToDo Redoing the poker charts

#+begin_src sh
poker-fold-writes --charts
#+end_src

#+RESULTS:
: writing charts

  #+begin_src haskell
writeAllCharts
  #+end_src

#+RESULTS:

#+begin_src haskell
writeChartOptions "other/basedark.svg" baseDarkChart
#+end_src

** 9 versus 2

  #+begin_src haskell
  (Just m) <- readSomeRanges
  let o2 = m Map.! "o2"
  let o9 = m Map.! "o9"
  #+end_src

#+RESULTS:

  #+begin_src haskell :results output
sum $ (\f o o' -> f (o * 0.5 - o' * 0.1111)) <$> o2 <*> o9
  #+end_src

#+RESULTS:
: 40.753043983751574


#+begin_src haskell
view #hudOptions $ pixelChart pixelColors any2
#+end_src

#+RESULTS:
: HudOptions {chartAspect = FixedAspect 1.5, axes = [(Priority {priority = 5.0},AxisOptions {bar = Nothing, adjust = Just (Adjustments {maxXRatio = 8.0e-2, maxYRatio = 6.0e-2, angledRatio = 0.12, allowDiagonal = True}), ticks = Ticks {style = TickLabels ["A","K","Q","J","T","9","8","7","6","5","4","3","2"], gtick = Nothing, ttick = Just (TextStyle {size = 4.0e-2, color = Colour 0.05 0.05 0.05 0.40, anchor = AnchorMiddle, hsize = 0.45, vsize = 1.1, vshift = -0.25, rotation = Nothing, scalex = ScaleX, frame = Nothing},3.3e-2), ltick = Nothing}, place = PlaceTop}),(Priority {priority = 5.0},AxisOptions {bar = Nothing, adjust = Just (Adjustments {maxXRatio = 8.0e-2, maxYRatio = 6.0e-2, angledRatio = 0.12, allowDiagonal = True}), ticks = Ticks {style = TickLabels ["2","3","4","5","6","7","8","9","T","J","Q","K","A"], gtick = Nothing, ttick = Just (TextStyle {size = 4.0e-2, color = Colour 0.05 0.05 0.05 0.40, anchor = AnchorMiddle, hsize = 0.45, vsize = 1.1, vshift = -0.25, rotation = Nothing, scalex = ScaleX, frame = Nothing},3.3e-2), ltick = Nothing}, place = PlaceLeft})], frames = [], legends = [], titles = [(Priority {priority = 10.0},Title {text = "Suited", style = TextStyle {size = 6.0e-2, color = Colour 0.05 0.05 0.05 0.40, anchor = AnchorMiddle, hsize = 0.45, vsize = 1.1, vshift = -0.25, rotation = Nothing, scalex = ScaleX, frame = Nothing}, place = PlaceTop, anchor = AnchorMiddle, buffer = 4.0e-2}),(Priority {priority = 10.0},Title {text = "Offsuited", style = TextStyle {size = 6.0e-2, color = Colour 0.05 0.05 0.05 0.40, anchor = AnchorMiddle, hsize = 0.45, vsize = 1.1, vshift = -0.25, rotation = Nothing, scalex = ScaleX, frame = Nothing}, place = PlaceLeft, anchor = AnchorMiddle, buffer = 5.0e-2})]}

- [X] rect
  - [X] colors
  - [X] night colors
- [X] o2
  - [X] format
  - [X] same colors as rect
- [X] o9
- [ ] fcr
  - [ ] fold call raise (%???)
- [ ] pixelo9
  - [ ] top header too extended
- [ ] compare29
  - [ ] text not showing

* Recent Research

Heads-up odds versus any2

[[file:other/odds2.svg]]

Odds versus full table

[[file:other/odds9.svg]]

Tier shifts between heads-up and full table.

[[file:other/compare29.svg]]

top 10% range:

[[file:other/top10.svg]]

* chart references

[[file:other/count.svg]]


[[file:other/fcr.svg]]
[[file:other/freq.svg]]
[[file:other/o2.svg]]
[[file:other/pixelo9.svg]]
[[file:other/rect.svg]]
[[file:other/text.svg]]

* Speed testing & development

#+begin_src elisp
(setq haskell-process-args-cabal-repl '("poker-fold:exe:poker-fold-speed"))
#+end_src

#+begin_src haskell :results output :exports both
:r
:set prompt " > "
:set -Wno-type-defaults
:set -Wno-name-shadowing
:set -XOverloadedStrings
import Perf
import Chart
import Poker.Charts
import Data.FormatN
import qualified Data.Text as Text
import qualified Data.Map.Strict as Map
import Prettyprinter
putStrLn "ok"
#+end_src

#+RESULTS:
: [8 of 8] Compiling Poker.Charts     ( src/Poker/Charts.hs, interpreted ) [Source file changed]
: Ok, 8 modules loaded.
: >
: ok


#+begin_src haskell
writeAllCharts
#+end_src

#+RESULTS:

#+begin_src haskell
:i LegendOptions
#+end_src

#+RESULTS:
#+begin_example
type LegendOptions :: *
data LegendOptions
  = LegendOptions {Chart.Hud.size :: {-# UNPACK #-}Double,
                   Chart.Hud.buffer :: {-# UNPACK #-}Double,
                   vgap :: {-# UNPACK #-}Double,
                   hgap :: {-# UNPACK #-}Double,
                   textStyle :: !TextStyle,
                   innerPad :: {-# UNPACK #-}Double,
                   outerPad :: {-# UNPACK #-}Double,
                   Chart.Hud.frame :: !(Maybe RectStyle),
                   Chart.Hud.place :: !Place,
                   overallScale :: {-# UNPACK #-}Double,
                   content :: ![(Text, Chart)]}
  	-- Defined in ‘Chart.Hud’
instance Eq LegendOptions -- Defined in ‘Chart.Hud’
instance Show LegendOptions -- Defined in ‘Chart.Hud’
#+end_example



** ToDo poker-fold chart bugs

- [ ] compare29.svg no data???
- [ ] fcr - bad colours
- [ ] o2 - bad colours, formatting
- [ ] oixelo9 - bad axes label placement, colours
- [ ] rect bad colours



#+RESULTS:

** hand evaluation speed

#+begin_src sh  :results output :exports both
poker-fold-speed
#+end_src

#+RESULTS:
: label1              label2              results
:
: handRank            time                1.44e4
: handRank afap       time                1.33e4
: handRank ffap       time                5.23e6
: handRank f|         time                5.35e6
: handRank |f         time                1.36e4
: handRank |f|        time                6.46e6

** shuffling

#+begin_src sh :results output :exports both
poker-fold-speed --shuffle -n 100000
#+end_src

#+RESULTS:
#+begin_example
label1              label2              results

rvi - list          time                2.40e-1
rvi - list f        time                1.87e2
rvi - single        time                5.43e1
rvi - single f      time                5.53e1
rvil - single       time                2.78e3
rviv - list         time                6.00e-4
rviv - list f       time                1.04e4
rviv - single       time                1.58e3
rviv - single f     time                2.75e3
#+end_example

#+begin_src sh :results output :exports both
poker-fold-speed --shuffle -n 10000
#+end_src

#+RESULTS:
#+begin_example
label1              label2              results

rvi - list          time                2.46e-1
rvi - list f        time                2.01e2
rvi - single        time                5.54e1
rvi - single f      time                5.41e1
rvil - single       time                3.03e3
rviv - list         time                6.00e-4
rviv - list f       time                1.36e4
rviv - single       time                2.95e3
rviv - single f     time                4.10e3
#+end_example


Creating a list of random variates stays lazy as perf is WHNF in the output. Forcing the list fixes this. For a single rvi, the output is computed, and force being added is probably creating an intermediary.

rvil is a list version of rviv.

#+begin_src sh :results output :exports both
poker-fold-speed --shuffle -n 10000 --allocation +RTS -T -RTS
#+end_src

#+RESULTS:
#+begin_example
label1              label2              results

rvi - list          allocation          0
rvi - list f        allocation          5.21e2
rvi - single        allocation          0
rvi - single f      allocation          0
rvil - single       allocation          3.39e3
rviv - list         allocation          0
rviv - list f       allocation          4.13e4
rviv - single       allocation          7.69e3
rviv - single f     allocation          7.68e3
#+end_example

#+begin_src sh :results output :exports both
poker-fold-speed --shuffle -n 100000 --allocation +RTS -T -RTS
#+end_src

#+RESULTS:
#+begin_example
label1              label2              results

rvi - list          allocation          0
rvi - list f        allocation          5.43e2
rvi - single        allocation          0
rvi - single f      allocation          1.88e1
rvil - single       allocation          3.49e3
rviv - list         allocation          0
rviv - list f       allocation          4.13e4
rviv - single       allocation          7.60e3
rviv - single f     allocation          7.60e3
#+end_example

Something allocated to the heap for rvi - single, forced, harming performance.

** handRankS

#+begin_src haskell :results output :exports both
import Data.Bifunctor
:t count
fmap (fmap (bimap getSum ((/10000.0) . fromIntegral))) $ execPerfT ((,) <$> count <*> time) $ handRankS_P 10000
#+end_src

#+RESULTS:
:
: count :: Measure IO (Sum Int)
: fromList [("flushS",(10000,1709.5718)),("kindS",(9239,1160.7222)),("ranksSet",(9703,1324.894)),("straightS",(9703,421.3668))]


handRankS seems bug-free

#+begin_src haskell :results output :exports both
cs = card7sS 100000
:t cs
:t handRankS
V.length $ applyV handRankS cs
#+end_src

#+RESULTS:
:
: cs :: Cards2S
: handRankS :: CardsS -> HandRank
: 100000

#+begin_src haskell :results output :exports both
:t fromIntegral <$> time
:t statify
#+end_src

#+RESULTS:
: fromIntegral <$> time :: Num b => Measure IO b
: statify
:   :: Ord a =>
:      StatDType -> Map.Map a [[Double]] -> Map.Map [a] [Double]
